<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好きだよ！</title>
  
  <subtitle>Alin&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sukidayo.top/"/>
  <updated>2019-11-26T14:36:03.811Z</updated>
  <id>http://www.sukidayo.top/</id>
  
  <author>
    <name>Alin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随手写</title>
    <link href="http://www.sukidayo.top/2019/11/26/dairy1126/"/>
    <id>http://www.sukidayo.top/2019/11/26/dairy1126/</id>
    <published>2019-11-26T14:20:00.000Z</published>
    <updated>2019-11-26T14:36:03.811Z</updated>
    
    <content type="html"><![CDATA[<p>想起去年疯狂给公众号写稿子的日子。也许公众号始终是太「公众」了，许多本来应该洒下的话却羞于启齿。不如现在这样，在互联网的一角建一个不会被搜索引擎收录的博客，想到什么就写点什么，心情不好也可以无限期地搁在一边。</p><a id="more"></a><p>给家里打了电话。晚上桃李的炒饭有些凉了；宿舍桌子下的猕猴桃软得刚刚好；又一次在科协的周会上走神；突然打算做出一些改变，从明早开始吧；北京今天天气不错；晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想起去年疯狂给公众号写稿子的日子。也许公众号始终是太「公众」了，许多本来应该洒下的话却羞于启齿。不如现在这样，在互联网的一角建一个不会被搜索引擎收录的博客，想到什么就写点什么，心情不好也可以无限期地搁在一边。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sukidayo.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://www.sukidayo.top/2019/11/25/recursion/"/>
    <id>http://www.sukidayo.top/2019/11/25/recursion/</id>
    <published>2019-11-25T10:50:25.000Z</published>
    <updated>2019-11-26T14:16:45.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这是给软件93班写的C语言辅导资料之二，权当复习，挂在博客上方面随时修改。</p><p>递归指的是在函数的定义中使用函数自身的方法。 </p> <a id="more"></a> <p><strong>递归</strong>（recursive）函数是“自己调用自己”的函数。因为函数不可以一直不停地调用自己，所以递归函数一定具备结束条件。</p><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">()</span> </span>&#123; </span><br><span class="line">statements; </span><br><span class="line">... ... ...  </span><br><span class="line">recursion(); <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">recursion(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用以下流程图表示：</p><p><img src="/2019/11/25/recursion/recursion_0.png" alt="递归流程图"></p><p>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</p><p>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。</p><h2 id="递归示例"><a href="#递归示例" class="headerlink" title="递归示例"></a>递归示例</h2><p>下面的示例使用递归函数完成了一些简单的操作。</p><h3 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;<span class="comment">//递归结束的条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i * factorial(i - <span class="number">1</span>);<span class="comment">//如果不满足递归结束的条件，则反复调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 的阶乘为 %f\n"</span>, i, factorial(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算斐波那契数列"><a href="#计算斐波那契数列" class="headerlink" title="计算斐波那契数列"></a>计算斐波那契数列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonaci</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//递归结束的条件1</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//递归结束的条件2</span></span><br><span class="line">    <span class="keyword">return</span> fibonaci(i - <span class="number">1</span>) + fibonaci(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t\n"</span>, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是$C.R.A.Hoare$于1962年提出的一种划分交换排序。它采用了一种分治的策略。</p><p>该方法的基本思想是：</p><ul><li><p>1．先从数列中取出一个数作为基准数。</p></li><li><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p></li><li><p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p></li></ul><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此可以对快速排序作了进一步的说明：挖坑填数+分治法：</p><p>以一个数组作为示例，取区间第一个数为基准数。</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><em>72</em></td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table></div><p>初始时，$i = 0; j = 9;  X = a[i] = 72$</p><p>由于已经将$ a[0]$ 中的数保存到 $X $中，可以理解成在数组 $a[0] $上挖了个坑，可以将其它数据填充到这来。</p><p>从$j$开始向前找一个比$X$小或等于$X$的数。当$j=8$，符合条件，将$a[8]$挖出再填到上一个坑$a[0]$中。$a[0]=a[8]; i++;$ 这样一个坑$a[0]$就被搞定了，但又形成了一个新坑$a[8]$，这怎么办？再找数字来填$a[8]$这个坑。这次从$i$开始向后找一个大于$X$的数，当$i=3$，符合条件，将$a[3]$挖出再填到上一个坑中$a[8]=a[3]; j—;$</p><p>  数组变为：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><strong>48</strong></td><td>6</td><td>57</td><td><em>88</em></td><td>60</td><td>42</td><td>83</td><td>73</td><td><strong>88</strong></td><td>85</td></tr></tbody></table></div><p>  $i = 3;  j = 7;  X=72$</p><p>  再重复上面的步骤，先从后向前找，再从前向后找。</p><p>  从$j$开始向前找，当$j=5$，符合条件，将a[5]挖出填到上一个坑中，$a[3] = a[5]; i++;$</p><p>  从$i$开始向后找，当$i=5$时，由于$i==j$退出。</p><p>  此时，$i = j = 5$，而$a[5]$刚好又是上次挖的坑，因此将$X$填入$a[5]$。</p><p>  数组变为：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><strong>48</strong></td><td>6</td><td>57</td><td><strong>42</strong></td><td>60</td><td><em>72</em></td><td>83</td><td>73</td><td><strong>88</strong></td><td>85</td></tr></tbody></table></div><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对$a[0]-a[4]$和$a[6]-a[9]$这二个子区间重复上述步骤就可以了。  </p><p>对挖坑填数进行总结:</p><ul><li>1．$i =L; j = R$; 将基准数挖出形成第一个坑$a[i]$。</li><li>2．$j—$由后向前找比它小的数，找到后挖出此数填前一个坑$a[i]$中。</li><li>3．$i++$由前向后找比它大的数，找到后也挖出此数填到前一个坑$a[j]$中。</li><li>4．重复执行2，3二步，直到$i==j$，将基准数填入$a[i]$中。</li></ul><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x)  <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x)  <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quick_sort(s, l, i - <span class="number">1</span>);  <span class="comment">// 递归调用</span></span><br><span class="line">        quick_sort(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote id="fn_1"><sup>1</sup>. 有的书上是以中间的数作为基准数的，实现这个方便非常方便，将中间的数和第一个数进行交换就可以了。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速排序部分来自网络</span><br><span class="line">作者：MoreWindows</span><br><span class="line">原文：https://blog.csdn.net/morewindows/article/details/6684558</span><br></pre></td></tr></table></figure><h2 id="OJ题目思路解析"><a href="#OJ题目思路解析" class="headerlink" title="OJ题目思路解析"></a>OJ题目思路解析</h2><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p>不难得出，如果要上到第$n$级台阶，那么之前一定在第$n-1$级台阶或第$n-2$级台阶上。加上边界条件，解决。</p><h3 id="学生信息"><a href="#学生信息" class="headerlink" title="学生信息"></a>学生信息</h3><p>重点是排序。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>关于循环链表的建立：与普通链表的建立没有很大区别，将尾节点的$next$域置为第一个元素（注意：不是头结点，而是第一个实际元素）的地址即可。</p><p>算法思路：如果目前有$n$名幸存者，那么进行完一轮报数后剩余$(n-1)$名幸存者。当场上仅有一名幸存者时，结束。</p><p>这个问题也可以用非递归的算法解决。</p><h2 id="OJ题目答案"><a href="#OJ题目答案" class="headerlink" title="OJ题目答案"></a>OJ题目答案</h2><p><del>这里没有，别想了。</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;这是给软件93班写的C语言辅导资料之二，权当复习，挂在博客上方面随时修改。&lt;/p&gt;
&lt;p&gt;递归指的是在函数的定义中使用函数自身的方法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.sukidayo.top/categories/C-C/"/>
    
    
      <category term="递归" scheme="http://www.sukidayo.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>yolov3使用指南（Win10）</title>
    <link href="http://www.sukidayo.top/2019/11/24/yolov3/"/>
    <id>http://www.sukidayo.top/2019/11/24/yolov3/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2019-11-26T14:17:16.629Z</updated>
    
    <content type="html"><![CDATA[<p>yolov3官方给出了Linux系统下构建的详细流程，然而VMware的虚拟机并不支持GPU，本人又懒得装双系统；于是探索了不少教程，终于在Win10下成功构建了yolov3并完成了模型的训练。将配置环境/训练/识别的过程记在这里，以便日后使用。<strong>本文仍在施工中</strong>。</p> <a id="more"></a> <h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>​    Windows 10</p><p>​    VS2017</p><p>​    CUDA10.1</p><p>​    OpenCV 3.2.0</p><h2 id="后续内容施工中……"><a href="#后续内容施工中……" class="headerlink" title="后续内容施工中……"></a>后续内容施工中……</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yolov3官方给出了Linux系统下构建的详细流程，然而VMware的虚拟机并不支持GPU，本人又懒得装双系统；于是探索了不少教程，终于在Win10下成功构建了yolov3并完成了模型的训练。将配置环境/训练/识别的过程记在这里，以便日后使用。&lt;strong&gt;本文仍在施工中&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>随手写：记我的第一和第二个大一</title>
    <link href="http://www.sukidayo.top/2019/11/23/dairy1123/"/>
    <id>http://www.sukidayo.top/2019/11/23/dairy1123/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2019-11-26T14:22:01.320Z</updated>
    
    <content type="html"><![CDATA[<p>这些文字早在暑假就该被写好的，然而像网络学堂的作业一样被我推而又推。恰今晚有闲，索性把还能记起的片段写下来，记录我度过了的和正在度过的大学一年级。</p><a id="more"></a><p>我不愿把我的第一个大一定义成「失败」的，但回想起来，除了与室友好友相处的短暂美好时光，三百余日的经历中竟一时难以找出可称为「闪光」的节点。我讨厌运算放大器、讨厌反射系数和动态电路、讨厌二学位申请记录里「未通过」三个字、也讨厌自己无规律的作息、低下的效率。现在想来，浑浑噩噩度过的那一年中我最正确的决定，也许就是递交了转系申请书。<br>面试没有想象中的那么难，选择从八降九更像是我与自己的和解：回想起之前那一年，之所以过得那么难受，也许正是因为高估了自己的能力、妄图把所有事情都做好，结果每个方面都归于平庸。重启大一，我有更多的时间去试错、去尝试原来高压生活下不敢触及的事。我明白我不能像大佬那样面面俱到，因此无需事事都与top人物攀比，如此大概、能过得轻松许多吧。<br>新的大一，虽然年纪比同班同学们大了不少，但我想我已经不再迷茫了，至少我找到了该努力的方向。社工也好、科创也好，虽然不知道自己能做到如何地步，但努力吧、努力吧。<br>也希望列表各位诸事顺遂、学业有成。<br>今晚计划吃火锅，也许会开始的很晚，想一起吃锅的可以联系我。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些文字早在暑假就该被写好的，然而像网络学堂的作业一样被我推而又推。恰今晚有闲，索性把还能记起的片段写下来，记录我度过了的和正在度过的大学一年级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sukidayo.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://www.sukidayo.top/2019/11/21/linkedlist/"/>
    <id>http://www.sukidayo.top/2019/11/21/linkedlist/</id>
    <published>2019-11-21T10:50:25.000Z</published>
    <updated>2019-11-26T14:16:31.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>这是给软件93班写的C语言辅导资料之一，权当复习，挂在博客上方面随时修改。</p><p>本文主要介绍C语言中单链表的相关操作</p> <a id="more"></a> <p>对于一组数据的存储，通常有两种方法：数组和链表</p><p>在C语言中，数组是一组<strong>地址连续</strong>的存储单元，依次存储数据元素。</p><p><img src="/2019/11/21/linkedlist/image-20191121100943216.png" alt="数组的存储方式"></p><p>链表（本文只涉及单链表）是一组<strong>地址任意</strong>的存储单元，存储的是<strong>“节点”</strong>，节点由<strong>数据域</strong>和<strong>指针域</strong>（指示后继元素位置）组成。节点的序列即称为链表。</p><p><img src="/2019/11/21/linkedlist/image-20191121101017506.png" alt="链表的存储方式"></p><p>数组是提前申请好固定大小的连续空间，然后往空间内填充数据，每个数据的位置由<strong>数组的首地址和下标</strong>唯一确定；而链表则是一组离散的节点，每个节点<strong>指示下一个节点的位置</strong>，因此链表对空间的连续性没有要求。</p><p>通常来说，链表与数组相比有以下优缺点：</p><div class="table-container"><table><thead><tr><th></th><th>链表</th><th>数组</th></tr></thead><tbody><tr><td>内存占用</td><td>不需连续的内存空间</td><td>连续的内存空间</td></tr><tr><td>大小可变</td><td>大小可动态变化</td><td>大小固定，不能动态扩展</td></tr><tr><td>访问方式</td><td>只允许顺序访问</td><td>允许随机访问</td></tr><tr><td>增删元素</td><td>较快，$O(1)$<sup><a href="#fn_1" id="reffn_1">1</a></sup></td><td>较慢，$O(n)$</td></tr><tr><td>查询第$n$个元素</td><td>较慢，$O(n)$</td><td>较快，$O(1)$</td></tr></tbody></table></div><p>所以，对于数据规模未知/数据规模可能发生变化的数据集，通常采用链表的形式存储。<del>当然开一个巨大的数组也不是不行，只是会造成额外的内存开销。</del></p><blockquote id="fn_1"><sup>1</sup>. $O(1)$指常量时间，$O(n)$指线性时间。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><h3 id="链表常用操作"><a href="#链表常用操作" class="headerlink" title="链表常用操作"></a>链表常用操作</h3><p>以下所有操作基于这个链表结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure><h4 id="为什么引入头结点"><a href="#为什么引入头结点" class="headerlink" title="为什么引入头结点"></a>为什么引入头结点</h4><ul><li>头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义<del>（当然有些情况下也可存放链表的长度、用做监视哨等等）</del>。</li><li>若无头结点，对第一个元素的操作需要特殊处理，增加工作量的同时提高了产生bug的概率。</li><li>有了头结点后，<strong>对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。</strong></li></ul><p>链表的创建较为简单，这里不再赘述。</p><h4 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(LinkList <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历输出链表中所有元素的data域的值</span></span><br><span class="line">    LinkList h=<span class="built_in">list</span>;<span class="comment">//指向头节点</span></span><br><span class="line"><span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//当h是尾节点时结束循环 注意，循环中会将h指向h-&gt;next，因此第一次循环不会输出头结点的data域，而最后一次循环会输出尾节点的data域</span></span><br><span class="line">h = h-&gt;next;<span class="comment">//将h指向h的下一个节点，循环条件保证了此处内存访问不会越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, h-&gt;data);<span class="comment">//平凡的输出语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h4><p><img src="/2019/11/21/linkedlist/image-20191121103043870.png" alt="插入图示"></p><p>最初，$a_{i-1}$指向$a_i$，而根据图示，如果将一个元素e插入至$a_{i-1}$与$a_i$之间，只需要将插入的元素指向$a_i$的地址（即$a_{i-1}$的指针域），并将$a_{i-1}$指向的地址改为插入元素的地址。</p><p>只需要进行以下操作即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="keyword">int</span> _index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把数据插入一个链表中的第_index个位置</span></span><br><span class="line">LinkList t = <span class="built_in">list</span>, e;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; _index &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//这个循环用于抵达链表的第_index个位置或者抵达链表尾（当_index大于链表长度的情况，t在i&lt;_index前即指向了尾节点的指针域，即NULL，此时跳出循环,t==NULL）</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;<span class="comment">//如果链表长度不小于n</span></span><br><span class="line">e = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//申请新的空间</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"输入要插入的值"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e-&gt;data);<span class="comment">//这两行用于录入数据</span></span><br><span class="line">e-&gt;next = t-&gt;next;<span class="comment">//新申请的空间（即上图的节点e）指向（（插入位置前的节点）所指向的位置），即节点e指向插入位置后面的节点，也就是上图中的 使e指向a_i</span></span><br><span class="line">t-&gt;next = e;<span class="comment">//插入位置前的节点指向新建立的节点，也就是上图中的a_&#123;i-1&#125;指向e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//链表长度小于n，这里写错误处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//由于头节点的引入以及尾节点指针域置为NULL的操作，此处理方法适用于链表内的所有节点</span></span><br></pre></td></tr></table></figure><h4 id="链表节点的删除"><a href="#链表节点的删除" class="headerlink" title="链表节点的删除"></a>链表节点的删除</h4><p><img src="/2019/11/21/linkedlist/image-20191121104218179.png" alt="删除图示"></p><p>如图，若要删除$a_{i-1}$与$a_{i+1}$之间的$a_i$元素，只需要将$a_{i-1}$跨过$a_i$指向$a_{i+1}$即可。不要忘记将$a_i$的空间释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="keyword">int</span> _index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中第_index个元素</span></span><br><span class="line">LinkList t = <span class="built_in">list</span>, in;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; _index &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in = t;</span><br><span class="line">t = t-&gt;next;<span class="comment">//in始终是t的前一个节点，这里的in是上图中的a_&#123;i-1&#125;，t是a_i</span></span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//这个循环用于抵达链表的第_index个位置或者抵达链表尾（当_index大于链表长度的情况，t在i&lt;_index前即指向了尾节点的指针域，即NULL，此时跳出循环,t==NULL）</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in-&gt;next = t-&gt;next;<span class="comment">//把a_&#123;i-1&#125;的指针域置为a_i的指针域，即指向a_&#123;i+1&#125;</span></span><br><span class="line"><span class="built_in">free</span>(t);<span class="comment">//释放掉a_i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//链表长度小于n，这里写错误处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ题目解析"><a href="#OJ题目解析" class="headerlink" title="OJ题目解析"></a>OJ题目解析</h3><p>Work in progress…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;这是给软件93班写的C语言辅导资料之一，权当复习，挂在博客上方面随时修改。&lt;/p&gt;
&lt;p&gt;本文主要介绍C语言中单链表的相关操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.sukidayo.top/categories/C-C/"/>
    
    
      <category term="链表" scheme="http://www.sukidayo.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>施工中...</title>
    <link href="http://www.sukidayo.top/2019/11/21/index/"/>
    <id>http://www.sukidayo.top/2019/11/21/index/</id>
    <published>2019-11-20T16:00:00.000Z</published>
    <updated>2019-11-26T14:32:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事建了个小站，偶尔往里面写点乱七八糟的东西；也许会记录一下做过的项目、或者单纯写点日记和游记；域名正便宜，服务器暂且挂在GitHub上。一时半会可能做不出留言评论功能，有事还是要靠微信QQ交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闲来无事建了个小站，偶尔往里面写点乱七八糟的东西；也许会记录一下做过的项目、或者单纯写点日记和游记；域名正便宜，服务器暂且挂在GitHub上。一时半会可能做不出留言评论功能，有事还是要靠微信QQ交流。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
