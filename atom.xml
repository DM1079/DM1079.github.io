<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好きだよ！</title>
  
  <subtitle>Alin&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sukidayo.top/"/>
  <updated>2020-08-24T13:02:46.920Z</updated>
  <id>http://www.sukidayo.top/</id>
  
  <author>
    <name>Alin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔 | 降转这一年</title>
    <link href="http://www.sukidayo.top/2020/06/01/%E9%9A%8F%E7%AC%94%20%E9%99%8D%E8%BD%AC%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <id>http://www.sukidayo.top/2020/06/01/%E9%9A%8F%E7%AC%94%20%E9%99%8D%E8%BD%AC%E8%BF%99%E4%B8%80%E5%B9%B4/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-08-24T13:02:46.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="随笔-降转这一年"><a href="#随笔-降转这一年" class="headerlink" title="随笔 | 降转这一年"></a>随笔 | 降转这一年</h3><p><code>注：这篇文章充斥着大量神志不清、模糊、中二和鸡血，请慎重阅读。懒得插图了，就这样吧。</code></p><p>又一年转系季。一觉醒来看到群中999+消息，我恍若回到了一年前握着文件夹踏入东主楼的那个下午——虽然那已经是一整年前的事情了。</p><a id="more"></a><h5 id="1-我想做游戏"><a href="#1-我想做游戏" class="headerlink" title="#1 我想做游戏"></a>#1 我想做游戏</h5><blockquote><p>“那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行。”</p></blockquote><p>做一下自我介绍，我在18年入学，分数低于录取分数线3分，领军计划，无竞赛基础。</p><p>很久很久以前，我就对计算机有了一些兴趣，这份兴趣来自小学订阅的电脑杂志（虽然是为了附带光盘里的小游戏）、偷偷借自同学的PSP、或者是小时候爸爸带我一起玩的超级玛丽和魂斗罗。作为一个玩游戏长大的小朋友，我在某个时刻产生了“做属于自己的游戏”的想法——一直持续至今。</p><p>依据高考之前我粗浅的认识，想做游戏，在大学要么就去学码要么就去学美术。但美术是不可能美术的，手残这辈子都画不出像样的画的（我错了今年考完试就学），于是华大学的软件学院成为了我的目标，考不上的话北大也可以。</p><p>但高考数学错的两道选填显然不允许我这么做。裸分不上线的考生自然是没什么人权的，招生组也不会倾泻多少无意义的热情。“你的分数填计算机大类没什么希望，想填就填吧。”我记得出分后与招生组的这段对话。</p><p>于是，我自然却有点意外地被二志愿电子信息录取。从后来与他人的闲谈中得知，线下能录入电子信息类是非常罕见的事情，而电子系与软院的接近给了转系的优势。现在想来，我依然感谢命运那时赐予我的次优解。</p><h5 id="2-我和我的第一个大一"><a href="#2-我和我的第一个大一" class="headerlink" title="#2 我和我的第一个大一"></a>#2 我和我的第一个大一</h5><blockquote><p>“如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。”</p></blockquote><p>以下文字完全摘自我在去年生日之际写的总结：</p><p><em>我不愿把我的第一个大一定义成「失败」的，但回想起来，除了与室友好友相处的短暂美好时光，三百余日的经历中竟一时难以找出可称为「闪光」的节点。我讨厌运算放大器、讨厌反射系数和动态电路、讨厌二学位申请记录里「未通过」三个字、也讨厌自己无规律的作息、低下的效率。现在想来，浑浑噩噩度过的那一年中我最正确的决定，也许就是递交了转系申请书。</em></p><p>我的第二个大一即将过完，两相比较，大约能看的更清楚一些。</p><p>从高中到大学，我的第一反应是手忙脚乱：课程、科创、社工、无穷无尽的小组讨论和习题。也许忙起来之后就会忘记许多东西吧，比如烦恼、迷茫和曾经的梦想。我开始了解推研并不是80%就够，知道许多爆肝做的作品比不上大佬随手写的玩具。在一个众人推着我向前走的环境里，也许真的很难迈出改变的一步。我想我的大学四年也许就如此平凡地度过，在这之后推研或者推不了研，找个大厂或小厂，996到45岁。我想那时候的我善于接受命运的安排，比起风险更偏爱平稳。</p><h5 id="3-我的转系申请书"><a href="#3-我的转系申请书" class="headerlink" title="#3 我的转系申请书"></a>#3 我的转系申请书</h5><blockquote><p>“远离梦想的生活是微小的死亡”</p></blockquote><p>——一切都在电子电路与系统基础这门课程期中考试时戛然而止。我打心底里敬佩李国林老师，也试着去理解这门课，但是电路仍然令我生厌，并丢给了我一个34分的分数。大学以来的第一个不及格，虽然期末考好的话期中占比会降到10%，但那天晚上我仍然想了好久。</p><p>我想到在大一上学期末也曾考虑过转系，但是由于成绩处于边缘，这个念头迅速被我活跃的自我否定想法清除掉了。我想那时候我的保守来自我的自卑，我从来认为自己做不到这些事情，“避免丢脸和失望，不去做没有把握的事情”，为了避免失败而避免了开始。</p><p>我想到了北岛的诗，如#1和#2上所写；我想到了我似乎原来是想要入软院而非电子的，我捡起了积满尘土的做游戏的梦想，我意识到远离梦想的生活是微小的死亡。电子系的课程其实并不对我胃口，在电子行业的工作也将不会是我想要的未来。何不去搏一把？</p><p>转系申请开始前，大概一个半月两个月左右，我开始准备转系资料。电电期中考的失败是一个重要的契机，感谢glgg那年把题目出的很难。倘若我考的比较好的话，可能就会按照电子的培养方案一直读下去了。</p><h5 id="4-我和我自己和解"><a href="#4-我和我自己和解" class="headerlink" title="#4 我和我自己和解"></a>#4 我和我自己和解</h5><blockquote><p>“满天都是星星，好像一场冻结了的大雨。那时候我们一无所有，也没有什么能妨碍我们享受静夜。”</p></blockquote><p>提交材料、找导员签字、面试、焦躁不安的等待。这是我对去年五月份最后的记忆。</p><p>去年软院的申请人数出人意料地少，而我也成为了这一现象的受益者，如愿以偿的转入了软院。以下文段依然摘自我去年的生日总结：</p><p><em>面试没有想象中的那么难，选择从八降九更像是我与自己的和解：回想起之前那一年，之所以过得那么难受，也许正是因为高估了自己的能力、妄图把所有事情都做好，结果每个方面都归于平庸。重启大一，我有更多的时间去试错、去尝试原来高压生活下不敢触及的事。我明白我不能像大佬那样面面俱到，因此无需事事都与top人物攀比，如此大概、能过得轻松许多吧。</em><br><em>新的大一，虽然年纪比同班同学们大了不少，但我想我已经不再迷茫了，至少我找到了该努力的方向。社工也好、科创也好，虽然不知道自己能做到如何地步，但努力吧、努力吧。</em></p><p>我开始审视我从前的生活，审视我无意义的畏缩和逃避，开始意识到有些事情原来是可以触到的。转系也不是什么危险的事情，大学最多可以读六年，我有四次机会去试。既然如此，为什么还要接受命运塞给我的次优解呢？</p><p>我想，转系这件事带给我的最大价值并不在于可以换一套培养方案（虽然这个也很重要），而在于给我的生活提供了另一种可能，去抓住转瞬即逝的疯狂点子而不是思考成功的可能性。</p><p>我开始变得开朗，去主动结交好友、加入社团、尝试许多之前不敢试的事情。我想这是转系带给我的最珍贵的东西。</p><p>转系结束之后的那个学期，我把课程退到6分，来了一场说走就走的旅行。</p><h5 id="5-我的第二个大一和未来"><a href="#5-我的第二个大一和未来" class="headerlink" title="#5 我的第二个大一和未来"></a>#5 我的第二个大一和未来</h5><blockquote><p>“我早就决定吃想吃的东西，过短命的人生了。”</p></blockquote><p>第二个大一也即将画上句号，虽然这一年暂未有什么亮眼的成果，但我宛若新生。我已经可以笑着拥抱未来的一切，去和生活给我的安排讨价还价，去更多地考虑成功而非担心失败。</p><p>我开始理解，二十岁附近浪费些许时间其实并没有什么不妥。因为我们足够年轻，我们可以去尝试足够多的可能性。倘若能回到我第一个大一，我想对那时候的我说一句：“不必畏手畏脚，你还年轻，你有足够多的时间去试错。”</p><p>我想我已经有了足够的勇气，在追寻梦想的道路上大步前进了吧。</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>我的转系自述</p><p>我的博客</p><p>我的胡思乱想和神志不清</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;随笔-降转这一年&quot;&gt;&lt;a href=&quot;#随笔-降转这一年&quot; class=&quot;headerlink&quot; title=&quot;随笔 | 降转这一年&quot;&gt;&lt;/a&gt;随笔 | 降转这一年&lt;/h3&gt;&lt;p&gt;&lt;code&gt;注：这篇文章充斥着大量神志不清、模糊、中二和鸡血，请慎重阅读。懒得插图了，就这样吧。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;又一年转系季。一觉醒来看到群中999+消息，我恍若回到了一年前握着文件夹踏入东主楼的那个下午——虽然那已经是一整年前的事情了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日记" scheme="http://www.sukidayo.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>206</title>
    <link href="http://www.sukidayo.top/2020/02/06/dairy0206/"/>
    <id>http://www.sukidayo.top/2020/02/06/dairy0206/</id>
    <published>2020-02-06T15:35:18.000Z</published>
    <updated>2020-02-06T15:37:28.754Z</updated>
    
    <content type="html"><![CDATA[<p>这是人们会说起的一年</p><p>这是人们会说起的一年，</p><p>这是人们说起就沉默的一年。</p><p>老人看着年轻人死去。</p><p>傻瓜看着聪明人死去。</p><p>大地不再生产，它吞噬。</p><p>天空不下雨，只下铁。</p><p>作者 / [德国] 布莱希特，1940</p><p>翻译 / 黄灿然</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是人们会说起的一年&lt;/p&gt;
&lt;p&gt;这是人们会说起的一年，&lt;/p&gt;
&lt;p&gt;这是人们说起就沉默的一年。&lt;/p&gt;
&lt;p&gt;老人看着年轻人死去。&lt;/p&gt;
&lt;p&gt;傻瓜看着聪明人死去。&lt;/p&gt;
&lt;p&gt;大地不再生产，它吞噬。&lt;/p&gt;
&lt;p&gt;天空不下雨，只下铁。&lt;/p&gt;
&lt;p&gt;作者 / [
      
    
    </summary>
    
    
    
      <category term="日记" scheme="http://www.sukidayo.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11/29 随手写</title>
    <link href="http://www.sukidayo.top/2019/11/29/dairy1129/"/>
    <id>http://www.sukidayo.top/2019/11/29/dairy1129/</id>
    <published>2019-11-29T10:58:31.000Z</published>
    <updated>2020-06-29T14:40:01.027Z</updated>
    
    <content type="html"><![CDATA[<p>难得，竟然在周五就把一周的所有任务都清理掉了。</p><a id="more"></a><p>这周里开不完的会、做不完的外联和访谈、小组pre、一周速成Kotlin和JavaScript，一项项都不容易但终于把压在一起的任务一点点清理掉了，甚至忙中偷空建立起了博客。好久没有空出一个完全自由的周末了，雪降下的时刻在对话框敲出“下雪了”三个字，心情也轻快起来。</p><p>计划早起拍一点雪景、把挂画布布置到寝室、买一束花、周日懒懒地睡到中午、把读到一半的天气之子看完。 </p><p><img src="/2019/11/29/dairy1129/1.jpg" alt="1"></p><p><img src="/2019/11/29/dairy1129/2.jpg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;难得，竟然在周五就把一周的所有任务都清理掉了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sukidayo.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>11/26 随手写</title>
    <link href="http://www.sukidayo.top/2019/11/26/dairy1126/"/>
    <id>http://www.sukidayo.top/2019/11/26/dairy1126/</id>
    <published>2019-11-26T14:20:00.000Z</published>
    <updated>2019-12-01T11:00:12.545Z</updated>
    
    <content type="html"><![CDATA[<p>想起去年疯狂给公众号写稿子的日子。也许公众号始终是太「公众」了，许多本来应该洒下的话却羞于启齿。不如现在这样，在互联网的一角建一个不会被搜索引擎收录的博客，想到什么就写点什么，心情不好也可以无限期地搁在一边。</p><a id="more"></a><p>给家里打了电话。晚上桃李的炒饭有些凉了；宿舍桌子下的猕猴桃软得刚刚好；又一次在科协的周会上走神；突然打算做出一些改变，从明早开始吧；北京今天天气不错；晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想起去年疯狂给公众号写稿子的日子。也许公众号始终是太「公众」了，许多本来应该洒下的话却羞于启齿。不如现在这样，在互联网的一角建一个不会被搜索引擎收录的博客，想到什么就写点什么，心情不好也可以无限期地搁在一边。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sukidayo.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://www.sukidayo.top/2019/11/25/recursion/"/>
    <id>http://www.sukidayo.top/2019/11/25/recursion/</id>
    <published>2019-11-25T10:50:25.000Z</published>
    <updated>2019-11-26T14:16:45.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这是给软件93班写的C语言辅导资料之二，权当复习，挂在博客上方面随时修改。</p><p>递归指的是在函数的定义中使用函数自身的方法。 </p> <a id="more"></a> <p><strong>递归</strong>（recursive）函数是“自己调用自己”的函数。因为函数不可以一直不停地调用自己，所以递归函数一定具备结束条件。</p><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">()</span> </span>&#123; </span><br><span class="line">statements; </span><br><span class="line">... ... ...  </span><br><span class="line">recursion(); <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">recursion(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用以下流程图表示：</p><p><img src="/2019/11/25/recursion/recursion_0.png" alt="递归流程图"></p><p>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</p><p>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。</p><h2 id="递归示例"><a href="#递归示例" class="headerlink" title="递归示例"></a>递归示例</h2><p>下面的示例使用递归函数完成了一些简单的操作。</p><h3 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;<span class="comment">//递归结束的条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i * factorial(i - <span class="number">1</span>);<span class="comment">//如果不满足递归结束的条件，则反复调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 的阶乘为 %f\n"</span>, i, factorial(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算斐波那契数列"><a href="#计算斐波那契数列" class="headerlink" title="计算斐波那契数列"></a>计算斐波那契数列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonaci</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//递归结束的条件1</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//递归结束的条件2</span></span><br><span class="line">    <span class="keyword">return</span> fibonaci(i - <span class="number">1</span>) + fibonaci(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t\n"</span>, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是$C.R.A.Hoare$于1962年提出的一种划分交换排序。它采用了一种分治的策略。</p><p>该方法的基本思想是：</p><ul><li><p>1．先从数列中取出一个数作为基准数。</p></li><li><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p></li><li><p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p></li></ul><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此可以对快速排序作了进一步的说明：挖坑填数+分治法：</p><p>以一个数组作为示例，取区间第一个数为基准数。</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><em>72</em></td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table></div><p>初始时，$i = 0; j = 9;  X = a[i] = 72$</p><p>由于已经将$ a[0]$ 中的数保存到 $X $中，可以理解成在数组 $a[0] $上挖了个坑，可以将其它数据填充到这来。</p><p>从$j$开始向前找一个比$X$小或等于$X$的数。当$j=8$，符合条件，将$a[8]$挖出再填到上一个坑$a[0]$中。$a[0]=a[8]; i++;$ 这样一个坑$a[0]$就被搞定了，但又形成了一个新坑$a[8]$，这怎么办？再找数字来填$a[8]$这个坑。这次从$i$开始向后找一个大于$X$的数，当$i=3$，符合条件，将$a[3]$挖出再填到上一个坑中$a[8]=a[3]; j—;$</p><p>  数组变为：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><strong>48</strong></td><td>6</td><td>57</td><td><em>88</em></td><td>60</td><td>42</td><td>83</td><td>73</td><td><strong>88</strong></td><td>85</td></tr></tbody></table></div><p>  $i = 3;  j = 7;  X=72$</p><p>  再重复上面的步骤，先从后向前找，再从前向后找。</p><p>  从$j$开始向前找，当$j=5$，符合条件，将a[5]挖出填到上一个坑中，$a[3] = a[5]; i++;$</p><p>  从$i$开始向后找，当$i=5$时，由于$i==j$退出。</p><p>  此时，$i = j = 5$，而$a[5]$刚好又是上次挖的坑，因此将$X$填入$a[5]$。</p><p>  数组变为：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td><strong>48</strong></td><td>6</td><td>57</td><td><strong>42</strong></td><td>60</td><td><em>72</em></td><td>83</td><td>73</td><td><strong>88</strong></td><td>85</td></tr></tbody></table></div><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对$a[0]-a[4]$和$a[6]-a[9]$这二个子区间重复上述步骤就可以了。  </p><p>对挖坑填数进行总结:</p><ul><li>1．$i =L; j = R$; 将基准数挖出形成第一个坑$a[i]$。</li><li>2．$j—$由后向前找比它小的数，找到后挖出此数填前一个坑$a[i]$中。</li><li>3．$i++$由前向后找比它大的数，找到后也挖出此数填到前一个坑$a[j]$中。</li><li>4．重复执行2，3二步，直到$i==j$，将基准数填入$a[i]$中。</li></ul><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x)  <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x)  <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quick_sort(s, l, i - <span class="number">1</span>);  <span class="comment">// 递归调用</span></span><br><span class="line">        quick_sort(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote id="fn_1"><sup>1</sup>. 有的书上是以中间的数作为基准数的，实现这个方便非常方便，将中间的数和第一个数进行交换就可以了。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速排序部分来自网络</span><br><span class="line">作者：MoreWindows</span><br><span class="line">原文：https:&#x2F;&#x2F;blog.csdn.net&#x2F;morewindows&#x2F;article&#x2F;details&#x2F;6684558</span><br></pre></td></tr></table></figure><h2 id="OJ题目思路解析"><a href="#OJ题目思路解析" class="headerlink" title="OJ题目思路解析"></a>OJ题目思路解析</h2><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p>不难得出，如果要上到第$n$级台阶，那么之前一定在第$n-1$级台阶或第$n-2$级台阶上。加上边界条件，解决。</p><h3 id="学生信息"><a href="#学生信息" class="headerlink" title="学生信息"></a>学生信息</h3><p>重点是排序。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>关于循环链表的建立：与普通链表的建立没有很大区别，将尾节点的$next$域置为第一个元素（注意：不是头结点，而是第一个实际元素）的地址即可。</p><p>算法思路：如果目前有$n$名幸存者，那么进行完一轮报数后剩余$(n-1)$名幸存者。当场上仅有一名幸存者时，结束。</p><p>这个问题也可以用非递归的算法解决。</p><h2 id="OJ题目答案"><a href="#OJ题目答案" class="headerlink" title="OJ题目答案"></a>OJ题目答案</h2><p><del>这里没有，别想了。</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;这是给软件93班写的C语言辅导资料之二，权当复习，挂在博客上方面随时修改。&lt;/p&gt;
&lt;p&gt;递归指的是在函数的定义中使用函数自身的方法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.sukidayo.top/categories/C-C/"/>
    
    
      <category term="递归" scheme="http://www.sukidayo.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>yolov3使用指南（Win10）</title>
    <link href="http://www.sukidayo.top/2019/11/24/yolov3/"/>
    <id>http://www.sukidayo.top/2019/11/24/yolov3/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2019-11-26T14:17:16.629Z</updated>
    
    <content type="html"><![CDATA[<p>yolov3官方给出了Linux系统下构建的详细流程，然而VMware的虚拟机并不支持GPU，本人又懒得装双系统；于是探索了不少教程，终于在Win10下成功构建了yolov3并完成了模型的训练。将配置环境/训练/识别的过程记在这里，以便日后使用。<strong>本文仍在施工中</strong>。</p> <a id="more"></a> <h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>​    Windows 10</p><p>​    VS2017</p><p>​    CUDA10.1</p><p>​    OpenCV 3.2.0</p><h2 id="后续内容施工中……"><a href="#后续内容施工中……" class="headerlink" title="后续内容施工中……"></a>后续内容施工中……</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yolov3官方给出了Linux系统下构建的详细流程，然而VMware的虚拟机并不支持GPU，本人又懒得装双系统；于是探索了不少教程，终于在Win10下成功构建了yolov3并完成了模型的训练。将配置环境/训练/识别的过程记在这里，以便日后使用。&lt;strong&gt;本文仍在施工中&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>11/23 随手写：记我的第一和第二个大一</title>
    <link href="http://www.sukidayo.top/2019/11/23/dairy1123/"/>
    <id>http://www.sukidayo.top/2019/11/23/dairy1123/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2019-12-01T11:00:04.448Z</updated>
    
    <content type="html"><![CDATA[<p>这些文字早在暑假就该被写好的，然而像网络学堂的作业一样被我推而又推。恰今晚有闲，索性把还能记起的片段写下来，记录我度过了的和正在度过的大学一年级。</p><a id="more"></a><p>我不愿把我的第一个大一定义成「失败」的，但回想起来，除了与室友好友相处的短暂美好时光，三百余日的经历中竟一时难以找出可称为「闪光」的节点。我讨厌运算放大器、讨厌反射系数和动态电路、讨厌二学位申请记录里「未通过」三个字、也讨厌自己无规律的作息、低下的效率。现在想来，浑浑噩噩度过的那一年中我最正确的决定，也许就是递交了转系申请书。<br>面试没有想象中的那么难，选择从八降九更像是我与自己的和解：回想起之前那一年，之所以过得那么难受，也许正是因为高估了自己的能力、妄图把所有事情都做好，结果每个方面都归于平庸。重启大一，我有更多的时间去试错、去尝试原来高压生活下不敢触及的事。我明白我不能像大佬那样面面俱到，因此无需事事都与top人物攀比，如此大概、能过得轻松许多吧。<br>新的大一，虽然年纪比同班同学们大了不少，但我想我已经不再迷茫了，至少我找到了该努力的方向。社工也好、科创也好，虽然不知道自己能做到如何地步，但努力吧、努力吧。<br>也希望列表各位诸事顺遂、学业有成。<br>今晚计划吃火锅，也许会开始的很晚，想一起吃锅的可以联系我。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些文字早在暑假就该被写好的，然而像网络学堂的作业一样被我推而又推。恰今晚有闲，索性把还能记起的片段写下来，记录我度过了的和正在度过的大学一年级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sukidayo.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://www.sukidayo.top/2019/11/21/linkedlist/"/>
    <id>http://www.sukidayo.top/2019/11/21/linkedlist/</id>
    <published>2019-11-21T10:50:25.000Z</published>
    <updated>2019-11-26T14:16:31.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>这是给软件93班写的C语言辅导资料之一，权当复习，挂在博客上方面随时修改。</p><p>本文主要介绍C语言中单链表的相关操作</p> <a id="more"></a> <p>对于一组数据的存储，通常有两种方法：数组和链表</p><p>在C语言中，数组是一组<strong>地址连续</strong>的存储单元，依次存储数据元素。</p><p><img src="/2019/11/21/linkedlist/image-20191121100943216.png" alt="数组的存储方式"></p><p>链表（本文只涉及单链表）是一组<strong>地址任意</strong>的存储单元，存储的是<strong>“节点”</strong>，节点由<strong>数据域</strong>和<strong>指针域</strong>（指示后继元素位置）组成。节点的序列即称为链表。</p><p><img src="/2019/11/21/linkedlist/image-20191121101017506.png" alt="链表的存储方式"></p><p>数组是提前申请好固定大小的连续空间，然后往空间内填充数据，每个数据的位置由<strong>数组的首地址和下标</strong>唯一确定；而链表则是一组离散的节点，每个节点<strong>指示下一个节点的位置</strong>，因此链表对空间的连续性没有要求。</p><p>通常来说，链表与数组相比有以下优缺点：</p><div class="table-container"><table><thead><tr><th></th><th>链表</th><th>数组</th></tr></thead><tbody><tr><td>内存占用</td><td>不需连续的内存空间</td><td>连续的内存空间</td></tr><tr><td>大小可变</td><td>大小可动态变化</td><td>大小固定，不能动态扩展</td></tr><tr><td>访问方式</td><td>只允许顺序访问</td><td>允许随机访问</td></tr><tr><td>增删元素</td><td>较快，$O(1)$<sup><a href="#fn_1" id="reffn_1">1</a></sup></td><td>较慢，$O(n)$</td></tr><tr><td>查询第$n$个元素</td><td>较慢，$O(n)$</td><td>较快，$O(1)$</td></tr></tbody></table></div><p>所以，对于数据规模未知/数据规模可能发生变化的数据集，通常采用链表的形式存储。<del>当然开一个巨大的数组也不是不行，只是会造成额外的内存开销。</del></p><blockquote id="fn_1"><sup>1</sup>. $O(1)$指常量时间，$O(n)$指线性时间。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><h3 id="链表常用操作"><a href="#链表常用操作" class="headerlink" title="链表常用操作"></a>链表常用操作</h3><p>以下所有操作基于这个链表结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure><h4 id="为什么引入头结点"><a href="#为什么引入头结点" class="headerlink" title="为什么引入头结点"></a>为什么引入头结点</h4><ul><li>头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义<del>（当然有些情况下也可存放链表的长度、用做监视哨等等）</del>。</li><li>若无头结点，对第一个元素的操作需要特殊处理，增加工作量的同时提高了产生bug的概率。</li><li>有了头结点后，<strong>对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。</strong></li></ul><p>链表的创建较为简单，这里不再赘述。</p><h4 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(LinkList <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历输出链表中所有元素的data域的值</span></span><br><span class="line">    LinkList h=<span class="built_in">list</span>;<span class="comment">//指向头节点</span></span><br><span class="line"><span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//当h是尾节点时结束循环 注意，循环中会将h指向h-&gt;next，因此第一次循环不会输出头结点的data域，而最后一次循环会输出尾节点的data域</span></span><br><span class="line">h = h-&gt;next;<span class="comment">//将h指向h的下一个节点，循环条件保证了此处内存访问不会越界</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, h-&gt;data);<span class="comment">//平凡的输出语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h4><p><img src="/2019/11/21/linkedlist/image-20191121103043870.png" alt="插入图示"></p><p>最初，$a_{i-1}$指向$a_i$，而根据图示，如果将一个元素e插入至$a_{i-1}$与$a_i$之间，只需要将插入的元素指向$a_i$的地址（即$a_{i-1}$的指针域），并将$a_{i-1}$指向的地址改为插入元素的地址。</p><p>只需要进行以下操作即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="keyword">int</span> _index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把数据插入一个链表中的第_index个位置</span></span><br><span class="line">LinkList t = <span class="built_in">list</span>, e;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; _index &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//这个循环用于抵达链表的第_index个位置或者抵达链表尾（当_index大于链表长度的情况，t在i&lt;_index前即指向了尾节点的指针域，即NULL，此时跳出循环,t==NULL）</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;<span class="comment">//如果链表长度不小于n</span></span><br><span class="line">e = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//申请新的空间</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"输入要插入的值"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e-&gt;data);<span class="comment">//这两行用于录入数据</span></span><br><span class="line">e-&gt;next = t-&gt;next;<span class="comment">//新申请的空间（即上图的节点e）指向（（插入位置前的节点）所指向的位置），即节点e指向插入位置后面的节点，也就是上图中的 使e指向a_i</span></span><br><span class="line">t-&gt;next = e;<span class="comment">//插入位置前的节点指向新建立的节点，也就是上图中的a_&#123;i-1&#125;指向e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//链表长度小于n，这里写错误处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//由于头节点的引入以及尾节点指针域置为NULL的操作，此处理方法适用于链表内的所有节点</span></span><br></pre></td></tr></table></figure><h4 id="链表节点的删除"><a href="#链表节点的删除" class="headerlink" title="链表节点的删除"></a>链表节点的删除</h4><p><img src="/2019/11/21/linkedlist/image-20191121104218179.png" alt="删除图示"></p><p>如图，若要删除$a_{i-1}$与$a_{i+1}$之间的$a_i$元素，只需要将$a_{i-1}$跨过$a_i$指向$a_{i+1}$即可。不要忘记将$a_i$的空间释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(LinkList <span class="built_in">list</span>, <span class="keyword">int</span> _index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中第_index个元素</span></span><br><span class="line">LinkList t = <span class="built_in">list</span>, in;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; _index &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in = t;</span><br><span class="line">t = t-&gt;next;<span class="comment">//in始终是t的前一个节点，这里的in是上图中的a_&#123;i-1&#125;，t是a_i</span></span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//这个循环用于抵达链表的第_index个位置或者抵达链表尾（当_index大于链表长度的情况，t在i&lt;_index前即指向了尾节点的指针域，即NULL，此时跳出循环,t==NULL）</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">in-&gt;next = t-&gt;next;<span class="comment">//把a_&#123;i-1&#125;的指针域置为a_i的指针域，即指向a_&#123;i+1&#125;</span></span><br><span class="line"><span class="built_in">free</span>(t);<span class="comment">//释放掉a_i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//链表长度小于n，这里写错误处理语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ题目解析"><a href="#OJ题目解析" class="headerlink" title="OJ题目解析"></a>OJ题目解析</h3><p>Work in progress…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;这是给软件93班写的C语言辅导资料之一，权当复习，挂在博客上方面随时修改。&lt;/p&gt;
&lt;p&gt;本文主要介绍C语言中单链表的相关操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.sukidayo.top/categories/C-C/"/>
    
    
      <category term="链表" scheme="http://www.sukidayo.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>施工中...</title>
    <link href="http://www.sukidayo.top/2019/11/21/index/"/>
    <id>http://www.sukidayo.top/2019/11/21/index/</id>
    <published>2019-11-20T16:00:00.000Z</published>
    <updated>2019-11-26T14:32:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事建了个小站，偶尔往里面写点乱七八糟的东西；也许会记录一下做过的项目、或者单纯写点日记和游记；域名正便宜，服务器暂且挂在GitHub上。一时半会可能做不出留言评论功能，有事还是要靠微信QQ交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闲来无事建了个小站，偶尔往里面写点乱七八糟的东西；也许会记录一下做过的项目、或者单纯写点日记和游记；域名正便宜，服务器暂且挂在GitHub上。一时半会可能做不出留言评论功能，有事还是要靠微信QQ交流。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
